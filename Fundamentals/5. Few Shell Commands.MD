## Important shell commands

## ğŸ“‚ `ls` â€“ list directory contents
```bash
ls
ls -l
ls -ls
ls -lat
```
---
## ğŸ“‚ `cd` Command Examples

| Example         | Description                                       |
|-----------------|---------------------------------------------------|
| `cd /path/to/dir` | Change to an **absolute path** directory.       |
| `cd myfolder`    | Change to a **relative path** directory.         |
| `cd ..`          | Move **up one directory** level.                 |
| `cd ../..`       | Move **up two directory** levels.                |
| `cd -`           | Switch to the **previous directory** you were in.|
| `cd ~`           | Go to your **home directory** (`/home/user`).    |
| `cd`             | Same as `cd ~` â€” go to home directory.           |
| `cd /`           | Go to the **root directory** of the file system. |
| `cd $HOME`       | Another way to jump to your home directory.      |

ğŸ’¡ **Notes**:
- `~` is shorthand for the current userâ€™s home directory.
- `cd -` is super useful to jump back and forth between two directories.
---
## ğŸ“‚ `cp` Command Examples

| Example                                | Description                                                                 |
|-----------------------------------------|-----------------------------------------------------------------------------|
| `cp file1.txt file2.txt`               | Copy `file1.txt` to `file2.txt` (creates `file2.txt`).                      |
| `cp file1.txt /tmp/`                    | Copy `file1.txt` into the `/tmp` directory.                                 |
| `cp file1.txt file2.txt file3.txt /tmp/`| Copy multiple files into `/tmp/`.                                           |
| `cp -i file1.txt file2.txt`             | **Prompt before overwriting** file2.txt if it exists.                       |
| `cp -v file1.txt file2.txt`             | **Verbose output** â€” show whatâ€™s being copied.                             |
| `cp -p file1.txt file2.txt`             | Preserve file attributes (mode, timestamps, owner).                        |
| `cp -r mydir newdir`                    | **Copy directories recursively** â€” including contents of `mydir`.          |
| `cp -r -v mydir /path/to/target/`      | Recursively and verbosely copy a directory into a target path.             |
| `cp -u file1.txt file2.txt`             | **Update only if source is newer** than destination.                       |
| `cp -a mydir /path/to/backup/`          | **Archive mode** â€” copy directories recursively and preserve all attributes. |
| `cp --backup file1.txt file2.txt`       | Make a **backup** if `file2.txt` exists before overwriting.                 |

ğŸ’¡ **Notes**:
- `-r` or `-R` â€” recursive copy.
- `-a` â€” archive mode (same as `-rpP`).
- `-i` â€” interactive mode.
- `-v` â€” verbose mode.
- `-p` â€” preserve file attributes.
---

## ğŸ“‚ `pwd` Command Examples

| Example | Description                                                                 |
|---------|-----------------------------------------------------------------------------|
| `pwd`   | Print the **full path** of your current working directory.                 |

ğŸ’¡ **Usage Notes**:
- `pwd` stands for "print working directory".
- Itâ€™s often the first command you use to confirm your location in the filesystem.
- The output is always an **absolute path** starting from `/`.

## ğŸ“‚ `mv` Command Examples

| Example                        | Description                                                   |
|--------------------------------|---------------------------------------------------------------|
| `mv file1.txt file2.txt`       | Rename `file1.txt` to `file2.txt`.                           |
| `mv file.txt /path/to/dir/`    | Move `file.txt` into `/path/to/dir/`.                       |
| `mv file1 file2 file3 /tmp/`   | Move multiple files into `/tmp/`.                          |
| `mv dir1 newdirname`           | Rename directory `dir1` to `newdirname`.                    |
| `mv -i file1 file2`            | **Prompt before overwriting** file2 if it exists.          |
| `mv -v file1 file2`            | **Verbose mode** â€” show whatâ€™s being moved/renamed.         |
| `mv -n file1 file2`            | **Do not overwrite** existing file2.                        |

ğŸ’¡ **Usage Notes**:
- `mv` works across directories and files â€” itâ€™s also your basic `rename`.
- Combine options like `mv -iv` for interactive & verbose.
- If you `mv` across filesystems (e.g. different drives), it will actually copy and then delete the original.
---
## ğŸ—‘ï¸ `rm` Command Examples

| Example               | Description                                                |
|------------------------|------------------------------------------------------------|
| `rm file1.txt`         | Remove a file named `file1.txt`.                          |
| `rm file1 file2`       | Remove multiple files.                                   |
| `rm -i file1.txt`      | **Interactive mode** â€” prompt before deleting.           |
| `rm -f file1.txt`      | **Force removal** â€” ignore warnings & donâ€™t prompt.      |
| `rm -v file1.txt`      | **Verbose mode** â€” show whatâ€™s being removed.            |
| `rm -r mydir`          | Recursively remove directory and its contents.           |
| `rm -rf mydir`         | Forcefully & recursively remove a directory.             |
| `rm -ri mydir`         | Interactive & recursive removal â€” prompts for each file. |

ğŸ’¡ **Usage Notes**:
- `rm` is **permanent** â€” deleted files canâ€™t easily be recovered.
- Use `-i` or `-I` to add safety prompts when youâ€™re unsure.
- `rm -rf /important/path` can cause data loss â€” **use carefully**.
---

## ğŸ“ `touch` Command Examples

| Example             | Description                                              |
|---------------------|----------------------------------------------------------|
| `touch file.txt`     | Create a new empty file named `file.txt`.                |
| `touch file1 file2`  | Create multiple empty files (`file1` and `file2`).       |
| `touch -a file.txt`  | Update only the **access time** of `file.txt`.           |
| `touch -m file.txt`  | Update only the **modification time** of `file.txt`.     |
| `touch -c file.txt`  | Do not create the file if it doesnâ€™t already exist.      |
| `touch -t 202406191200 file.txt` | Set the file's timestamp to **2024-06-19 12:00**. |

ğŸ’¡ **Usage Notes**:
- `touch` is commonly used to quickly **create empty files**.
- It also updates a fileâ€™s **timestamps** without changing its contents.
- `-t` accepts a timestamp in the format `[[CC]YY]MMDDhhmm[.ss]`.
---
## ğŸ“‚ `mkdir` Command Examples

| Example                | Description                                                  |
|------------------------|--------------------------------------------------------------|
| `mkdir newdir`          | Create a new directory named `newdir`.                       |
| `mkdir dir1 dir2`       | Create multiple directories (`dir1` and `dir2`).             |
| `mkdir -p parent/child` | Create parent directories as needed (`parent/child`).       |
| `mkdir -v newdir`       | Verbose output â€” show what directories are created.          |
| `mkdir -m 755 newdir`   | Set permissions (`rwxr-xr-x`) for the new directory.         |

ğŸ’¡ **Usage Notes**:
- `-p` is very useful for creating nested directories in one go.
- `-m` allows setting permissions at creation time.
- Without options, `mkdir` will fail if the parent directory doesnâ€™t exist.
---
## ğŸ—‘ï¸ `rmdir` Command Examples

| Example           | Description                                                  |
|-------------------|--------------------------------------------------------------|
| `rmdir dir1`       | Remove empty directory `dir1`.                             |
| `rmdir dir1 dir2`  | Remove multiple empty directories (`dir1` and `dir2`).      |
| `rmdir -v dir1`    | Verbose output â€” show each directory as itâ€™s removed.       |
| `rmdir -p a/b/c`   | Remove `c`, then `b`, then `a` â€” if all are empty.          |

ğŸ’¡ **Usage Notes**:
- `rmdir` only works on **empty directories**.
- To remove directories with contents, use `rm -r dir_name`.
- `-p` is useful for removing parent directories if theyâ€™re empty too.
---
## ğŸ” `find` Command Examples

| Example                                         | Description                                                   |
|-------------------------------------------------|---------------------------------------------------------------|
| `find . -name "file.txt"`                        | Search for a file named `file.txt` in current dir and subdirs. |
| `find /var/log -type f`                          | Find all **regular files** under `/var/log`.                  |
| `find /home -type d`                            | Find all **directories** under `/home`.                       |
| `find . -name "*.log"`                          | Find all files with `.log` extension.                        |
| `find . -iname "*.jpg"`                         | Case-insensitive search for files with `.jpg` extension.     |
| `find /path -mtime -7`                          | Find files modified in the **last 7 days**.                  |
| `find . -size +100M`                            | Find files **larger than 100MB**.                            |
| `find . -exec rm {} \;`                         | Find and **delete** all matched files.                       |
| `find . -exec cp {} /backup/ \;`                | Find and **copy** all matched files to `/backup/`.           |
| `find . -type f -perm 644`                      | Find files with **specific permissions** (rw-r--r--).         |

---

ğŸ’¡ **Usage Notes**:
- `find` is **very powerful** for searching and performing actions.
- `-exec ... \;` lets you run a command on each file found.
- You can also use `-maxdepth N` to restrict how deep the search goes.

```bash
find . -name "*.log"**
```
Here `.` represents CURRENT DIR; 

If you want to search in entire system give `/`
```bash
find / -name "*.log"
```
### ğŸ” `find . -exec rm {} \;` â€” Explanation & Examples

## ğŸ“œ Breakdown
- `find .` â€” Search the **current directory** and all its subdirectories.
- `-exec rm {} \;` â€” For **each file found**, execute `rm {}`:
  - `{}` is a placeholder for the file path.
  - `\;` ends the `-exec` action.

> ğŸ’¡ Meaning: **Find all matching files under `.` and delete them one by one.**

## ğŸ§ª Examples

Delete all `.log` files:
```bash
find . -name "*.log" -exec rm {} \;
```

Delete all empty files:
```bash
find . -type f -empty -exec rm {} \;
```

Delete all files larger than 100MB:
```bash
find . -type f -size +100M -exec rm {} \;
```

Delete all `.tmp` files except one directory:
```bash
find . -path "./important_dir" -prune -o -name "*.tmp" -exec rm {} \;
```

Delete matched files in batches (efficient version):
```bash
find . -name "*.log" -exec rm {} +
```

Prompt before deleting each file:
```bash
find . -name "*.log" -exec rm -i {} \;
```

## ğŸ’¡ Caution
âœ… Always do a dry-run first:
```bash
find . -name "*.log"
```

## ğŸ¯ Summary
- `find ... -exec rm {} \;` â€” Deletes matched files one by one.
- `-exec ... {} +` â€” Deletes matched files in batches.
- Test first without `-exec`.
- Add `-i` for safety.
### Another example
# ğŸ” `find . -exec cp {} /backup/ \;`

## ğŸ“œ Explanation
This command:
- Recursively searches (`find .`) in the **current directory**.
- For **each file** found, executes (`-exec`) the `cp {}` command to copy that file into the `/backup/` directory.
- `{}` is replaced with the fileâ€™s full path.
- `\;` ends the `-exec` action.

> ğŸ’¡ Meaning:  
> **Find all files under the current directory and copy them one by one into `/backup/`.**  
>  
> âœ… `/backup/` must already exist.

---

## ğŸ§ª Example
Copy all `.log` files into `/backup/`:
```bash
find . -name "*.log" -exec cp {} /backup/ \;
```

---

## âš ï¸ Notes
- `-exec cp {} /backup/ \;` **executes `cp` for each file separately** â€” can be slower with many files.
- Make sure `/backup/` is **writable** by the current user.
- To **copy directories recursively**, add `-r`:
```bash
find . -type d -exec cp -r {} /backup/ \;
```

---

## âš¡ Efficient Version
Copy files in **batches** (faster):
```bash
find . -name "*.log" -exec cp {} /backup/ +
```

---

## ğŸ¯ Summary
- `find . -exec cp {} /backup/ \;` â€” Copies each file individually.
- `find . -exec cp {} /backup/ +` â€” Copies multiple files per `cp` execution.
- Test with `find ...` first without `-exec`.
---



find â€“ search for files (find /path -name filename)

ln â€“ create hard or symbolic links (ln -s source target)
```

### Viewing & Editing Files
```bash
cat, less, more â€“ view files

tail, head â€“ view last/first N lines

grep â€“ search inside files (grep "text" file)

wc â€“ word/line/character count

diff â€“ compare files

sed â€“ stream editor (sed 's/old/new/g' file)

awk â€“ powerful text processing (awk '{print $1}' file)

nano, vim â€“ simple and advanced editors
```

### System Information & User Management
```bash
who, w, id â€“ whoâ€™s logged in, user IDs

ps, top, htop â€“ process status & monitoring

df, du â€“ disk usage & space

free â€“ memory usage

uname â€“ system/kernel info

uptime â€“ system uptime and load average

chmod, chown, chgrp â€“ change permissions and ownership

passwd â€“ change user password

useradd, userdel, usermod â€“ user management

groupadd, groupdel â€“ group management
```

### Networking & Connectivity
```bash
ping â€“ check connectivity

curl, wget â€“ download files & test HTTP endpoints

ssh â€“ remote login

scp â€“ secure file transfer

rsync â€“ efficient file syncing

ss, netstat â€“ show open connections and listening ports

host, dig, nslookup â€“ DNS lookups

ifconfig, ip addr â€“ view/change IP addresses
```

### Scripting & Automation
```bash
bash â€“ invoke a new bash shell

source â€“ read and execute commands from file

env, export â€“ environment variables

alias â€“ create shortcuts for commands

history â€“ show command history

crontab â€“ schedule periodic jobs

at â€“ schedule one-time jobs
```

###Package Management (differs per OS)
```bash
apt, apt-get â€“ package manager on Debian/Ubuntu

yum, dnf â€“ package manager on RHEL/CentOS/Fedora

rpm â€“ low-level package management on RHEL

snap, flatpak â€“ universal packages
```

### Process Control & Signals
```bash
kill, killall â€“ send signals to processes

bg, fg, jobs â€“ background/foreground job control

nohup â€“ keep processes running after logout

screen, tmux â€“ multiplex terminal sessions
```

### System Logs & Services
```bash
journalctl â€“ view systemd logs

systemctl â€“ control systemd services (start, stop, status, restart)

service â€“ traditional init scripts control
```

